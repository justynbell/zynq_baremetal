# Zynq Baremetal

The goal of this project was to understand the Zynq-7000 from initial powerup to executing a bare metal "hello world" application, and to free myself from the shackles of vendor-specific IDEs/applications (Vitis).

Embedded developers seem to forget that the only things needed for software to run on target platforms are source code, a compiler, a linker script, and a good understanding of how the platform works from power-on to code execution (a make system is nice too). This will serve as a baseline for any project involving a bare-metal application to be run on the Zynq's A9 application core, with a bitstream loaded into PL.

I'm using a Digilent Arty Z7 dev board, and their [OOB](https://digilent.com/reference/programmable-logic/arty-z7/demos/oob?srsltid=AfmBOooRiSoF28uRf-TT9-1zPwDm1w6xVPYmF6pqiC8LAMAB8CjwyyTn) demo HW and SW designs. But once this is understood, it should be seen how any application gets loaded, executed, debugged, and run on-target.

## The complete flow
This includes all the details to the lowest level I could find. Some of Xilinx's documentation is a little vague (to me).

On the Zynq, there exists BootROM code burned into the chip during manufacuring. At poweron, the Cortex-A9 program counter starts at address 0x00000000, which is actually pointing to BootROM (because of the High Vector remap from the SCTLR register). The Xilinx BootROM code executes, copies our "packaged code" (our FSBL, bitstream, and application need to be packaged into a boot image such that the BootROM can execute our code). It reads the Boot Image's header, does whatever it needs to do, etc. One of the final things the BootROM does it remaps the memory so that 0x00000000 points to OCM.

When the BootROM code is done, we jump to our FSBL.



0. When the Zynq powers on, or resets, the ARM Cortex-A9 cores start executing from a hardware-defined reset vector at address [idk, 0x00000000 or 0xFFFF0000, it depends on the SCTRL, System Control Register's V bit (13)]
1. 

# Project Structure
## BSP
### What is it?
The BSP directory contains all the Xilinx libraries needed for both the first stage bootloader (FSBL) as well as the application. It contains libraries for configuration and control of peripherals (PS and PL), clocking, register address definitions, etc. This is auto-generated in Vitis when creating a "Platform Project" and importing a HW design file (.xsa).

### Where does it come from?
Once you import an XSA from Vivado into a Vitis Platform Project, Vitis auto-generates the libraries, xparameters.h (which contains register definitions, clocking information, and other defines generated from your .xsa hardware design) and other support files. The whole thing was lifted from <the_vitis_workspace>/ps7_cortexa9_0/standalone_domain/bsp.

I'm trying not to modify, pare-down, optimize, or touch these files in any way (including the Makefiles), as when the hardware design changes significantly (new IP is added, removed, addresses changed) it's handy to have these files auto-generated by Vitis so they can be plopped into this Vitis-free project.

## FSBL
### What is it?
the FSBL directory contains the source code and linker script for the First Stage Bootloader used on the Zynq-7000. When the Zynq powers on, depending on its 